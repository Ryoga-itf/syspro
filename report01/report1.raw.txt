学籍番号: __STUDENT_ID__
名前: __STUDENT_NAME__
課題番号：1
練習問題番号：106
題名：システムプログラム 第1回レポート課題

バブル整列法より効率の良い整列法であり、
クイックソートよりも最悪計算量が良いことで有名であるイントロソートを実装した。

実装したコードは以下の通りである。
なお、制御の流れや変数の値を確認するための出力文を入れるために適宜標準出力に処理内容を出力している。
また、スワップ回数を数えるためのグローバル変数を定義し、スワップをするたびにインクリメントし、
最後にその回数を報告するようにしている。

__INCLUDE(./intro_sort.c)__

これを実行すると以下のような出力が得られた。

__INCLUDE(./intro_sort_output)__

性能を比較するためにバブル整列法のコードを改良して同様に実行した。
以下にそのコードを示す。
スワップ回数を数えるためのグローバル変数を定義し、スワップをするたびにインクリメントし、
最後にその回数を報告するようにしている。
なお、ソートする配列は両者で同じものにしている。

__INCLUDE(./bubble_sort.c)__

実行結果は以下の通りである。

__INCLUDE(./bubble_sort_output)__

比較すると、バブル整列法はスワップの回数は 108 回なのに対して、
実装したイントロソートでは 12 回で済んでおり、大幅に効率が良くなっていることがわかる。

2 つの整列方法の実行時間を time コマンドなどで確認し、実行時間への影響を調べた。

それぞれのソースコードに対して、#include <stdlib.h> を先頭行に追加し、main 関数を以下のように書き換えた。

int main(void) {
    int count = 50000;
    int *data = (int *)malloc(sizeof(int) * count);
    srand(0);
    for (int i = 0; i < count; i++) {
        data[i] = rand();
    }
    sort(data, count);
    printf("swap count: %d\n", g_swap_count);
    free(data);
    return 0;
}

また、出力処理についてもコードから除いた。
次に time コマンドを用いて実行時間を比較した。5 回測定し、それぞれ平均値を求めた。

バブル整列法：9136 ミリ秒
イントロソート：8 ミリ秒

圧倒的に効率的になっていることが確認できた。
